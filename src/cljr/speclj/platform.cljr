(ns speclj.platform
  (:require [clojure.string :as str]))

(defmacro if-cljs
  "Return then if we are generating cljs code and else for Clojure code.
   http://blog.nberger.com.ar/blog/2015/09/18/more-portable-complex-macro-musing
   https://github.com/nberger/more-macro-musings"
  [then else]
  (if (:ns &env) then else))

(defmacro try-catch-anything
  "Tries forms up until the last form, which is expected to be a `catch` form,
   except its type is missing; instead, `:default` is used in ClojureScript and
   `System.Exception` is used in Clojure CLR."
  [& forms]
  (let [body         (butlast forms)
        catch-form   (last forms)
        [catch-sym binding & catch-forms] (if (sequential? catch-form) catch-form [nil nil nil])
        catch-valid? (and (= 'catch catch-sym) (symbol? binding))]
    (if catch-valid?
      `(if-cljs
         (try ~@body
              (catch :default ~binding ~@catch-forms))
         (try ~@body
              (catch System.Exception ~binding ~@catch-forms)))
      `(throw (ex-info "Invalid catch form" {:catch '~catch-form})))))

(def endl Environment/NewLine)
(def file-separator System.IO.Path/DirectorySeparatorChar)

(defn re? [obj]
  (instance? System.Text.RegularExpressions.Regex obj))

(def throwable System.Exception)
(def exception System.Exception)

(defn- classname->filename [classname]
  (let [root-name (first (str/split classname #"\$"))]
    (str
      (str/replace root-name "." file-separator)
      ".clj")))

(declare ^:dynamic *bound-by-should-invoke*)

(defn bound-by-should-invoke? []
  (and (bound? #'*bound-by-should-invoke*)
       *bound-by-should-invoke*))

(defn difference-greater-than-delta? [expected actual delta]
  (> (abs (- (bigdec expected) (bigdec actual)))
     (abs (bigdec delta))))

(defn error-message [e] (.-Message e))

;; TODO [BAC]: FIXME
(defn stack-trace [e]
  ;(.-StackTrace e)
  )
(defn cause [e] (.-InnerException e))

;; TODO [BAC]: FIXME
(defn print-stack-trace [e]
  ;(Console/WriteLine "\n{0}" (.-StackTrace e))
  )

;; TODO [BAC]: FIXME
(defn failure-source [exception]
  ;(let [source    (nth (.-StackTrace exception) 0)
  ;      classname (.getClassName source)
  ;      filename  (classname->filename classname)]
  ;  (if-let [url nil ;(io/resource filename)
  ;           ]
  ;    (str (.getFile url) ":" (.getLineNumber source))
  ;    (str filename ":" (.getLineNumber source))))
  )

;; TODO [BAC]: FIXME
(defn elide-level? [stack-element]
  ;(let [classname (.getClassName stack-element)]
  ;  (or
  ;    (str/starts-with? classname "clojure.")
  ;    (str/starts-with? classname "speclj.")
  ;    (str/starts-with? classname "java.")))
  )

(defn type-name [t] (.-FullName t))
(defn format-seconds [secs] (.ToString secs "0.00000"))

(defn current-time [] (/ (.-Ticks DateTime/Now) TimeSpan/NanosecondsPerTick))

(defn secs-since [start] (/ (double (- (current-time) start)) 1000000000.0))

(defn dynamically-invoke [ns-name fn-name]
  (let [ns-sym (symbol ns-name)
        fn-sym (symbol (str ns-name "/" fn-name))
        expr   `(do (require '~ns-sym) (~fn-sym))]
    (eval expr)))

(defn exit [code] (Environment/Exit code))

(defn compiler-load [reader path]
  (clojure.lang.Compiler/load reader path path nil))

;(def new-line 10)

;(defn- read-in [] (when (.ready *in*) (.read *in*)))

;; TODO [BAC]: FIXME
(defn enter-pressed? []
  false
  ;(= (read-in) new-line)
  )

(defn get-name [ns] (.-Name ns))
(defn get-bytes [s]
  (.GetBytes System.Text.Encoding/UTF8 s))
